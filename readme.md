###### 1.守护线程
守护线程不会阻止JVM退出,当所有的工作线程都结束后,JVM正常会退出,daemon线程也会跟着结束.

###### 2.ThreadGroup
ThreadGroup就是线程组,可以把一堆线程加入一个线程组里,可以将一堆线程作为一个整体统一的管理和设置.  

在java里,每个线程都有一个父线程的概念,就是在哪个线程里创建这个线程,那么他的父线程就是谁.举例来说,
java都是通过main启动的,那么有一个主要的线程就是main线程.在main线程里启动的线程,父线程就是main线程.  

每个线程都必然属于一个线程组,默认情况下,创建一个线程如果没指定线程组,那么就会属于父线程的线程组,
main线程的线程组就是main ThreadGroup.  

java中线程都是有名字的,默认main线程的名字就是叫main,其他线程的名字一般是叫做Thread-0之类的.  

线程组其实也有父线程组的概念,我们创建线程组的时,如果没有手动指定他的父线程组,那么其实默认的父线程组
就是main线程的线程组

假如把一堆线程放到线程组里去,然后可以统一管理哪些东西?
- enumerate(): 复制线程组里的线程
- activeCount(): 获取线程组里活跃的线程
- getName()、getParent()、list()等等
- interrupt(): 打断所有的线程
- destroy(): 一次性destroy所有的线程

JDK虽然提供了ThreadGroup,一般开发或者是很多的开源项目里,ThreadGroup很少用,如果你要自己封装一堆线程的管理组件,
完全可以自己写

###### 3.线程启动过程
- 启动了线程之后就不能再重新启动了,因为启动之后,threadStatus就是非0的状态了,再次调用start方法会判断该状态,
  抛出异常
- 启动线程之后,这个线程就会加入之前处理好的那个线程组中
- 启动一个线程实际上走的是native方法:start0(),会实际的启动一个线程
- 一个线程启动之后就会执行run()方法

###### 4.yield
让出CPU执行权.  

如果要用这个方法的,必须在严格的测试环境下做大量的测试,验证在需要的场景下使用了yield方法,
真的可以达到需要的效果.很多人很少可以正确的使用这个yield方法,常见于debug和test场景下的程序.

在这样的一些场景下,他可以复现因为锁争用导致的一些bug.

他也可以用于设计一些并发控制的工具,比如说在java.util.concurrent.locks包下的一些类

###### 5.join
调用该方法的线程会等待被join的线程执行完毕后再继续执行.

比如main线程里面如果开启了一个其他线程,main线程就会跟其他线程开始并发的运行,一会执行main线程的代码,
一会儿会执行其他线程的代码.

main线程如果对那个线程调用了join的方法,那么就会导致main线程阻塞住,他会等待其他线程的代码逻辑执行结束,
那个线程执行完毕,main线程才会继续往下走
